The structure of Dictionary

Tolerant retrival

--------------------------------Dictionary------------------------------------------
The structure of Dictionary 
	词典的数据结构 简称词典

	初始字典

	储存 term     doc frequency      postings or pos_postings
		 a        65456				 -->  -->  --> ...
		 cat      45 				 -->  -->  --> ...
		 ...
	 
	类型 char[20] int				 postings*   (int* 型的)
	字节 20       4/8                4/8

 
===================================================================
词典的储存结构
	mian two choices：
		- Hash table （构建hash表
		- Tree       （建树
    两者在今日的IR系统中都有使用
	
	数据结构的选择
		- 词项的数目有多少？
		- 词项的数目是固定的还是经常变化？
		  在变化的情况下，是只插入新词项，还是同时要删除某些旧词项？ 
		- 不同词项的相对访问频率如何？
	(FB)
	
	
	
==========Hash Table======================
构建hash表
	优点：查询时间为O(1)
	缺点：1.只能进行1 vs 1的索引查询
				-无法进行容忍检索
				-无法用简单的方法来找到次要变量(理解一下，总之方便和不方便都有点极端)
		  2.如果词汇量不断增大，则需要隔一段时间来进行一次重新的哈希表构建
		        -增大空间，避免：溢出;冲突过多导致时间增大
				-改变构建hash table的方法

==========Tree============================
建树
	优点：支持前缀查询
	缺点：1.搜索速度慢 O(logM) 相比于O(1)的hash查询   //M为词项的数目，即词典大小
		  2.树的重新平衡操作代价大
	
	
	
	
	
	
	
	
	=============
B-tree (即B树，B-树，是个balance树)

B-tree 数据结构书上就有

B树结构词典通配符查询处理

	- 对mon*的查询操作，遍历B-树结构，返回区间mon ≤ t< moo上的词项term
	- 对*mon的查询操作，遍历反向B-树结构，返回区间nom ≤ t < non上的词项term
	- 对m*nchen的查询操作，在B‐树中分别查找满足m*和*nchen的词项集合，然后求交集
	- 然而对于上述一般通配查询的操作，开销太大。
	
	==============
