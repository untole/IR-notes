1.对于想同时满足的条件，直接用位运算AND即可

2.在大量数据中，很多词是仅包含在一部分文件中，
  所以矩阵稀疏
  
3.在磁盘中，直接扫是最快最方便的也是最常见的
  在内存中，可以使用可变长数组和链表。
  
Iverted Index 倒排索引
----------------------------------------------------------------
MAIN：Indexer steps: 

  Token sequence：
	Step 1：将每篇文章文章的单词拆分成 tokens ，
	        在表内只存word和所在文件编号 
	        (其中，去s等复数变单数、大写变小写等操作)
			(在lecture中没有看到did->do的形式)
	Step 2：合并----进行双关键字排序||核心步骤
	                (主关键字是字母表顺序，副为文件编号)
	Step 3：将相同单词合并并加上 frequency 量
	
		    此 frequency 只为出现在的文件的个数，非字数，也非出现的总次数	
	
            将所在文件编号按次形成 postings (用数组等)
			Step 2中的文件便被分成两份：
			1.词典Dictionary：包括words(tokens)和frequency
			2.Postings.
  
  现在index struction 已被建立
  素质三问：
  Q1.怎样高效index  
  Q2.需要多少储存空间(数据量很大)
  Q3.附加信息等
  
  
  A1：开头所提到的位运算符AND
      
	  用等效思想
	  将query中需要的比如
	  word1，word2的postings进行合并(merge)操作
	  merge过程中保留相同的
	  
  THEN....
    Boolean retrieval model：
	  使用and or not位运算符(思路)
	  使用时间长，使用广泛
  
  限制:复杂且多的位运算需要的时间成本高
  
  查询优化(很容易想到)：
		多查询所获得的可能答案随着boolean式子的复杂程度提升
		而减少，并且可以预见的是在前期的merge中会大量减少
		
		所以按照 frequency 从低到高排序进行merge
		(会减少更快，使得时间成本降低
		(然而减少是有限的：比如最后会以极少的可能答案
		 对 frequency 极高的词汇进行查询
		 很大几率为真，也有可能为假
  
  由上可知，只用操作得来的词典和postings只能完成一些简单的
    如布尔查询的 query
  
  
  
  接下来便是:
    clusteing:      将一些内容相似的文件归为一类
	classofication: 将新加入的文件分类(已有类别or未知类别)
	ranking：       怎样排列使查找最优？
---------------------------------------------------------------------
  需要做的还有很多：
	  跨语言查询
      问答
      文本总结
      文本挖掘(已看)	  
				
				
				
				
				
				
				